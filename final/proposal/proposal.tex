\documentclass{article}
% =======PACKAGES=======
% FORMATTING
\usepackage[margin=0.625in]{geometry}
\usepackage{parskip, setspace}
\setstretch{1.15}
% TYPESETTING - MATH
\usepackage{amsmath, amsfonts}
\usepackage{amsthm}
\usepackage[ruled, linesnumbered, noend]{algorithm2e}
\NewCommandCopy{\legacyunderscore}{\_}
\renewcommand{\_}{\ifincsname_\else\legacyunderscore\fi}
\usepackage{listings}
\usepackage{xcolor}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{lightgray},   
    commentstyle=\color{darkgray},
    keywordstyle=\color{red},
    numberstyle=\color{black},
    stringstyle=\color{violet},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}
% RICH
\usepackage{graphicx, caption}
\usepackage{hyperref}
% BIBLIOGRAPHY
\usepackage[
backend=biber,
sorting=ynt
]{biblatex}
\addbibresource{bib.bib}

\newcommand{\integer}{\textbf{int} }

% =======TITLE=======
\title{\vspace*{-0.625in}CS 529: Advanced Data Structures \& Algorithms \\ Final Project Proposal}
\author{Nathan Chapman, Hunter Lawrence, Andrew Struthers}
\date{\today}

\begin{document}

    \maketitle

\section*{Introduction}
One of the lessons we keep learning thoughout this class is that there are arbitrary decisions made in a lot of algorithms. For example, the string matching algorithm had a punishment of 2 for a gap, and a 1 for a mismatch. This, without proper explanation, is meaningless in the context of the problem and is an arbitrary decision in most cases. With Genetic Algorithms, there are typically a lot of arbitrary decisions. The population size, number of generations, and mutation rate are all usually selected based off of what ``feels right", and the algorithms that perform crossover, selection, and mutation are oftentimes unexplained and should just be accepted as ``correct". Additionally, the stopping criterion for evolutionary algorithms can be non-trivial. In optimization problems, the true optimal value is never known, so choosing when to stop evolving is also arbitrary. Typically it is solved by ending after a certain number of generations, but again, how many generations is an arbitrary choice. We could make this decision less arbitrary, by taking the Fast Fourier Transform of the best (or average) fitnesses each generation, and looking at the projection of the next generation's fitness. A classic combinatorial optimization problem is the Vehicle Routing Problem, where the best set of routes given to several vehicles that service customers must be terermined. Solving combinatorial optimization problems, especially with a Genetic Algorithm, is highly parallelizable and would benefit greatly from the speed parallelization offers as well as dynamic programming methods like memoization when calculating fitnesses. Likewise, the FFT can be massively parallelizable, leading to rapid increase in runtime efficiency. We would like to implement a parallelized and dynamic-programming based Genetic Algorithm to solve the Vehicle Routing Problem and determine the stopping criteria through Fourier analysis of the average fitnesses over generations. 


\section*{Genetic Algorithm}
A Genetic Algorithm is a type of evolutionary algorithm that attempts to follow the biological process of evolution. This algorithm works by first having an initial population generated randomly or by some smarter heuristic. The initial population then goes through typical genetic processes such as tournament or elitism selection, genetic crossover, and random mutation. Each member of the population is represented by a ``genome sequence", which encodes the some solution to an optimization problem somehow. The genetic processes operate on these genome sequences to form children. The children form the new population, and the cycle repeats, until some stopping criteria is met. As was pointed out in class, a lot of the decisions involved in using a GA to solve a problem are pretty arbitrary and disconnected from biological genetics. With this project, we want to determine the reason behind the usually arbitrary decisions when choosing a selection algorithm, a crossover algorithm, a mutation algorithm, and the hyperparameters of the model. We will analyze typical algorithms used for these processes and make decisions based off of problem context and evolutionary context to remove the arbitrary nature of these choices. Additionally, we will use the Fast Fourier Transform to determine the stopping criteria of the evolution process, as described below. 

\pagebreak

\section*{Determining the stopping criterion with the FFT}

There are many ways one can choose to stop an evolutionary algorithm.  Some common examples are\cite{StoppingCriteria}

\begin{itemize}
    \item MaxGenerations: The algorithm stops when the number of generations reaches \texttt{MaxGenerations}.
    
    \item MaxTime: The algorithm stops after running for an amount of time in seconds equal to \texttt{MaxTime}.
    
    \item FitnessLimit: The algorithm stops when the value of the fitness function for the best point in the current population is less than or equal to \texttt{FitnessLimit}.
    
    \item MaxStallGenerations: The algorithm stops when the average relative change in the fitness function value over \texttt{MaxStallGenerations is less than Function tolerance}.
    
    \item MaxStallTime: The algorithm stops if there is no improvement in the objective function during an interval of time in seconds equal to \texttt{MaxStallTime}.
    
    \item FunctionTolerance: The algorithm runs until the average relative change in the fitness function value over\\ \texttt{MaxStallGenerations} is less than Function tolerance.
\end{itemize}

Another method could be to perform a regression on the fitness data over time in order to predict the fitness of future generations.  Because such regressions can be computationally expensive, a better method is also sought.  

The Fast Fourier Transform (FFT) is able to be done, not only efficiently, but also is extremely conducive to being implemented on a massively parallel platform such as a GPU high-performance computing cluster.  Because of this, the FFT can effectively replace the previous regression algorithms.  This replacement allows us to efficiently formulate a way to predict the future behavior of the fitness function and stop early if the predicted behavior is insufficient.

\section*{Parallelization}
WHAT PARTS OF THIS PROJECT CAN BE DONE IN PARALLEL, WHAT WE WOULD USE PARALLELIZATION FOR, AND WHY WE CARE ABOUT PARALLELIZING THIS SHIT
\section*{Bringing It All Together}

\printbibliography

\end{document}