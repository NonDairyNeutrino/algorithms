\documentclass{article}
% =======PACKAGES=======
% FORMATTING
\usepackage[margin=0.625in]{geometry}
\usepackage{parskip, setspace}
\setstretch{1.15}
% TYPESETTING - MATH
\usepackage{amsmath, amsfonts}
\usepackage[ruled, linesnumbered, noend]{algorithm2e}
\usepackage{listings}
\usepackage{xcolor}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{lightgray},   
    commentstyle=\color{darkgray},
    keywordstyle=\color{red},
    numberstyle=\color{black},
    stringstyle=\color{violet},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}
% RICH
\usepackage{graphicx, caption}
\usepackage{hyperref}
% BIBLIOGRAPHY
\usepackage[
backend=biber,
sorting=ynt
]{biblatex}
\addbibresource{bib.bib}

\newcommand{\integer}{\textbf{int} }

% =======TITLE=======
\title{\vspace*{-0.625in}CS 529: Advanced Data Structures \& Algorithms \\ Assignment 3: String Matching Algorithms \& Dynamic Programming}
\author{Nathan Chapman, Hunter Lawrence, Andrew Struthers}
\date{\today}

\begin{document}

    \maketitle

    \section*{Introduction}

        Let $s_1, s_2$ be strings of length $m, n$ respectively, and $(i, j) \in \mathbb{Z}_m \times \mathbb{Z}_n$ i.e. $i, j$ are integers such that $0 \leq i \leq m - 1, 0 \leq j \leq n - 1$.  We consider the \texttt{opt} algorithm as defined in algorithm \ref{alg:opt}.

        \begin{function}
            \caption{opt(\integer $i$, \integer $j$)}
            \label{alg:opt}
            \KwIn{Indices of strings}
            \KwOut{Interger cost of best string alignment}
            
            \If{i = m}{
                \Return{2(n - j)}
            }
            \eIf{j = n}{
                \Return{2(m - i)}
            }{
                \eIf{$s_1$[i] = $s_2$[j]}{
                    $penalty \gets 0$
                }{
                    $penalty \gets 1$
                }
                \Return{$\min$(\opt(i + 1, j + 1) + penalty, \opt(i + 1, j) + 2, \opt(i, j + 1) + 2)}
            }
        \end{function}
    \section*{Runtime Complexity of \texttt{opt}}

    \texttt{opt(i, j)} seeks to find the penalty number for the optimal alignment of strings $s_1, s_2$ by exploring all possible penalty values which can be incurred by single character shifts. The results of this will allow a dynamic programming algorithm (specified later) to find out how to match the sequences according to this value.

    because \texttt{opt()}, as depicted above, incurs three separate recursive calls, only ending when either $i \leq  n $ OR $ j \leq m$. This results in an exponential worst case time efficiency of $O(3^n)$. 
    \section*{Sequence Alignment with Dynamic Programming}

    \section*{Finding an Optimal Alignment}

    \printbibliography

\end{document}