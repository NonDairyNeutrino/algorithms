\documentclass{article}
% =======PACKAGES=======
% FORMATTING
\usepackage[margin=0.625in]{geometry}
\usepackage{parskip, setspace}
\setstretch{1.15}
% TYPESETTING - MATH
\usepackage{amsmath, amsfonts, amsthm}
% TYPESETTING - ALGORITHMS
\usepackage[ruled, linesnumbered, noend]{algorithm2e}
\NewCommandCopy{\legacyunderscore}{\_}
\renewcommand{\_}{\ifincsname_\else\legacyunderscore\fi}
% TYPESETTING - CODE
\usepackage{listings}
\usepackage{xcolor}
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{lightgray},   
    commentstyle=\color{darkgray},
    keywordstyle=\color{red},
    numberstyle=\color{black},
    stringstyle=\color{violet},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}
% RICH
\usepackage{graphicx, caption}
\usepackage{hyperref}
% BIBLIOGRAPHY
% \usepackage[
% backend=biber,
% sorting=ynt
% ]{biblatex}
% \addbibresource{bib.bib}

\newcommand{\integer}{\textbf{int} } % for use in algorithm environments

% =======TITLE=======
\title{\vspace*{-0.625in}CS 529: Advanced Data Structures \& Algorithms \\ Assignment 8: Number Theory and NP Algorithms}
\author{Nathan Chapman, Hunter Lawrence, Andrew Struthers}
\date{\today}

\begin{document}

\maketitle

\section*{Number Theory}

    %3 pages of summary of number theory and proof of some statement

    \subsection*{Euclidean Division}

        It can be shown that for any pair of positive integers $a, b \in \mathbb{Z}^+$, there exists positive integers $q, r \in \mathbb{Z}^+$ such that 

        \begin{equation}
            a = q b + r
        \end{equation}

        where $0 \leq r < b$.  $q$ is called the ``quotient'' and $r$ is called the ``remainder''.  Because this is true for any pair, the same holds for every pair of positive integers.  A well known algorithm for calculating the remaineder is long division.

    \subsection*{Modular Arithmetic}

        If, as in Euclidean division, $a = q b + r$ we define the \emph{modulo} operation as

        \begin{equation}
            a \mod b = r
        \end{equation}

        For example

        \begin{align}
            \label{eq:isEven}      3  = 1 * 2   + 1  &\implies 3  \mod 2   = 1 \\
            \label{eq:clock}       15 = 1 * 12  + 3  &\implies 14 \mod 12  = 3 \\
            \label{eq:minutes}     90 = 1 * 60  + 30 &\implies 90 \mod 60  = 30 \\
            \label{eq:zeroQutient} 99 = 0 * 100 + 99 &\implies 99 \mod 100 = 99
        \end{align}

        Equation (\ref{eq:isEven}) is an example of how modular arithmetic to test if a number is even or odd.  Equation (\ref{eq:clock}) shows how modular arithmetic determines how to use a 12-hour based cycle of time.  Equation (\ref{eq:minutes}) furthermore determines how to use a 60-minute based cycle of time.  Equation (\ref{eq:zeroQutient}) is an example of a case where the quotient can be zero.

    \subsection*{Modular Exponentiation}

        A particularly interesting case is the modulus of an exponentiated positive integer as

        \begin{equation}
            c = b^e \mod m
        \end{equation}

        When $e < 0$, modular exponentiation can be defined using the modular multiplicative inverse $d$

        \begin{equation}
            b^e \mod m = d^{-e} \mod m
        \end{equation}

        and $b d \equiv 1 (\mod m)$.

    \subsection*{Modular Congruence}    

        Two positive integers $a, b \in \mathbb{Z}^+$ are said to be ``congruent mod m'', denoted $a \equiv b (\mod m)$, if 

        \begin{equation}
            a \mod m = b \mod m
        \end{equation}

        For example

        \begin{align}
            \label{eq:isEven}      3 \mod 2 = 1 = 5 \mod 2 &\implies 3 \equiv 5 \ (\mod 2) \\
            \label{eq:clock}       15 \mod 12 = 3 = 27 \mod 12 &\implies 15 \equiv 27 \ (\mod 12) \\
            \label{eq:minutes}     90 \mod 60 = 30 = 210 \mod 60 &\implies 90 \equiv 210 \ (\mod 60) \\
            \label{eq:zeroQutient} 99 \mod 100 = 99 = 1000000099 \mod 100 &\implies 99 \equiv 1000000099 \ (\mod 100)
        \end{align}

        Equation (\ref{eq:isEven}) is an example of how modular arithmetic to test if a number is even or odd.  Equation (\ref{eq:clock}) shows how modular arithmetic determines how to use a 12-hour based cycle of time.  Equation (\ref{eq:minutes}) furthermore determines how to use a 60-minute based cycle of time.  Equation (\ref{eq:zeroQutient}) is an example of a case where the quotient can be zero.

    \subsection*{Modular Multiplicative Inverse}

    \subsection*{Carmichael's Totient}

    \subsection*{Extended Euclidean Algorithm}

    \subsection*{Primality Testing}

\section*{Theorem 11.6}

    Prove that the $\gcd(n, m)$ is a product of primes that are common to $n$ and $m$, where the power of each prime in the product is the smaller of its orders in $n$ and $m$.

    \begin{proof}
        
    \end{proof}

\section*{Presburger and Halting Complexity}

\section*{Polynomial-time Algorithms}

    List 3 and justify

\section*{Encoding Schemes}

    Give a problem and two encoding schemes for its input.  Express its performance using your encoding schemes.

\end{document}